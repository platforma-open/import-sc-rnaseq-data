self := import("@platforma-sdk/workflow-tengo:tpl")
ll := import("@platforma-sdk/workflow-tengo:ll")
maps := import("@platforma-sdk/workflow-tengo:maps")

inputUtils := import(":libs.input-utils")

self.defineOutputs("importMode", "data", "spec", "samplesMap", "sampleColumnName")
self.awaitState("bundle", "PColumnBundle")
self.awaitState("inputSpec", "ResourceReady")
self.awaitState("inputData", "ResourceReady")

self.body(func(inputs) {
	spec := inputs.inputSpec
	bundle := inputs.bundle
	data := inputs.inputData
	
	importMode := undefined
	samplesMap := {}
	sampleColumnName := ""
	// Check for MTX (has cellRangerFileRole axis)
	if maps.containsKey(spec, "axesSpec") && spec.axesSpec != undefined {
		for _, axis in spec.axesSpec {
			if axis.name == "pl7.app/sc/cellRangerFileRole" {
				importMode = "mtx"
				break
			}
		}
	}
	
	// Check for h5ad, h5, seurat, or csv based on file extension
	if importMode == undefined && maps.containsKey(spec, "domain") && spec.domain != undefined {
		fileExt := spec.domain["pl7.app/fileExtension"]
		if fileExt == "h5ad" {
			importMode = "h5ad"
		} else if fileExt == "h5" {
			importMode = "h5"
		} else if fileExt == "rds" {
			importMode = "seurat"
		} else if fileExt == "csv" || fileExt == "csv.gz" || fileExt == "tsv" || fileExt == "tsv.gz" {
			importMode = "csv"
		}
	}
	
	if importMode == undefined {
		ll.panic("Could not infer import mode from dataset spec: %v", spec)
	}
	
	// For multi-sample formats, read list of samples from sampleGroup and 
	// create a new spec and data with samples, instead of sample groups
	if importMode == "h5ad" && inputUtils.isMultiSample(spec) {
		result := inputUtils.processMultiSample(bundle, "h5ad-multi-sample", "h5ad")
		return {
			importMode: result.importMode,
			spec: result.spec,
			data: result.data,
			samplesMap: result.samplesMap,
			sampleColumnName: result.sampleColumnName
		}
	} else if importMode == "seurat" && inputUtils.isMultiSample(spec) {
		result := inputUtils.processMultiSample(bundle, "seurat-multi-sample", "rds")
		return {
			importMode: result.importMode,
			spec: result.spec,
			data: result.data,
			samplesMap: result.samplesMap,
			sampleColumnName: result.sampleColumnName
		}
	}
	
	return {
		importMode: importMode,
		data: data,
		spec: spec,
		samplesMap: samplesMap,
		sampleColumnName: sampleColumnName
	}
})

