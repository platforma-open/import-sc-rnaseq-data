self := import("@platforma-sdk/workflow-tengo:tpl")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
render := import("@platforma-sdk/workflow-tengo:render")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
json := import("json")
maps := import("@platforma-sdk/workflow-tengo:maps")

targetOutputs := import(":libs.target-outputs")
pfSymbolsConv := import(":libs.pf-symbols-conv")
exportCountsConv := import(":libs.export-counts")
exportNormCountsConv := import(":libs.export-norm-counts")
resultsSummaryConv := import(":libs.results-summary-conv")
memoryCalc := import(":libs.memory-calc")

importCountsTpl := assets.importTemplate(":import-counts")
collectResultsTpl := assets.importTemplate(":collect-results")

makeTraceStep := func(blockId) {
	return {type: "milaboratories.import-sc-rnaseq-data", id: blockId, importance: 20, label: "Import scRNA-seq Data"}
}

self.awaitState("params", "ResourceReady")
self.awaitState("inputSpec", "ResourceReady")
self.awaitState("species", "ResourceReady")
self.awaitState("geneFormat", "ResourceReady")
self.awaitState("dataSize", "ResourceReady")
self.awaitState("sampleColumnName", "ResourceReady")

self.body(func(inputs) {
	blockId := inputs.params.blockId
	species := string(inputs.species.getData())
	geneFormat := string(inputs.geneFormat.getData())
	importMode := string(inputs.importMode)

	inputSpec := inputs.inputSpec
	inputData := inputs.inputData
	samplesIdToLabelMap := inputs.samplesIdToLabelMap
	sampleColumnName := inputs.sampleColumnName

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]
	sampleAxisSpec :=  inputSpec.axesSpec[0]
	compression := inputSpec.domain["pl7.app/compression"]
	
	// Calculate memory based on data size if available, otherwise use provided or default
	// at the moment we only calculate memory based by the first sample, assuming all samples
	// are similar in size
	dataSizeStr := undefined
	if !is_undefined(inputs.dataSize) {
		dataSizeStr = string(inputs.dataSize.getData())
	}
	calculatedMemGiB := memoryCalc.calculateMemory(dataSizeStr)

	// In MTX format aggregate by role axis
	aggregate := []
	if importMode == "mtx" {
		aggregate = [{
			name: "pl7.app/sc/cellRangerFileRole",
			optional: true
		}]
	}

	importingCountsResults := pframes.processColumn(
		{ spec: inputSpec, data: inputData }, importCountsTpl,
		targetOutputs.getTargetOutputs(species, blockId, sampleAxisSpec),
		{
		    aggregate: aggregate,
		    passKey: true,
		    traceSteps: [makeTraceStep(blockId)],
			extra: {
				species: species,
				fileExtension: fileExtension,
				geneFormat: geneFormat,
				dataSize: inputs.dataSize,
				importMode: importMode,
				compression: compression,
				samplesIdToLabelMap: samplesIdToLabelMap,
				sampleColumnName: sampleColumnName
			},
			metaExtra: {
				mem: calculatedMemGiB,
				cpu: 2
			}
		}
	)

	cellMetricsPf := importingCountsResults.xsvOutputFrame("cellMetrics")

	// Collect results (summary and gene symbols) from all samples
	collectResults := pframes.processColumn(
		importingCountsResults.output("rawCountsCsv"),
		collectResultsTpl,
		targetOutputs.getCollectResultsOutput(blockId),
		{
			aggregate: [sampleAxisSpec],
			traceSteps: [makeTraceStep(blockId)],
			extra: {
				species: species
			}
		}
	)

	// Build pFrame from rawCounts to pass directly to ptabler
	rawCountsPf := pframes.pFrameBuilder()
	rawCountsPf.add("rawCounts", importingCountsResults.outputSpec("rawCounts", "rawCounts"),
		importingCountsResults.outputData("rawCounts", "rawCounts"))
	rawCountsPfBuilt := rawCountsPf.build()


	resultsSummaryCsvData := collectResults.outputData("resultsSummaryCsv")
	resultsSummaryCsv := resultsSummaryCsvData.getFutureInputField(string(json.encode([])))
	resultsSummaryConvParams := resultsSummaryConv.getColumns(blockId, species, inputSpec)
	resultsSummaryPf := xsv.importFile(resultsSummaryCsv, "csv", resultsSummaryConvParams, {})

	geneSymbolsCsvData := collectResults.outputData("geneSymbolsCsv")
	geneSymbolsCsv := geneSymbolsCsvData.getFutureInputField(string(json.encode([])))
	geneSymbolsImportParams := pfSymbolsConv.getColumns(species)
	geneSymbolsPf := xsv.importFile(geneSymbolsCsv, "csv", geneSymbolsImportParams,{})

	// // Highly Variable Genes calculation
	// hvgResults := render.create(hvgTpl, {
	// 	csvCounts: filteredGenesCountsCsv,
	// 	normCounts: filteredGenesNormalizedCountsCsv
	// })

	// hvgCountsCsv := hvgResults.output("hvgCountsCsv")
	// hvgNormalizedCountsCsv := hvgResults.output("hvgNormalizedCountsCsv")

	// // Convert to pFrames
	// hvgCountsPf := xsv.importFile(hvgCountsCsv, "csv", countCsvParams, { mem: "16GiB", cpu: 1 })
	// hvgNormCountsPf := xsv.importFile(hvgNormalizedCountsCsv, "csv", normCountCsvParams, { mem: "16GiB", cpu: 1 })

	trace := pSpec.makeTrace(inputSpec, makeTraceStep(blockId))

	// Count matrix export defined with sample from inputSpec + previous specs
	sampleAxisSpecExp := copy(sampleAxisSpec)

	exportPfBuilder := pframes.pFrameBuilder()
	exportPfBuilder.add(
		"rawCount",
		trace.inject(exportCountsConv.getSpecs(blockId, species, sampleAxisSpecExp)),
		importingCountsResults.outputData("rawCounts", "rawCounts")
	)
	exportPfBuilder.add(
		"normCount",
		trace.inject(exportNormCountsConv.getSpecs(blockId, species, sampleAxisSpecExp)),
		importingCountsResults.outputData("normCounts", "normCounts")
	)
	// exportPfBuilder.add("rawHvgCount", trace.inject(exportCountsConv.getSpecs(blockId, species, sampleAxisSpec)), hvgCountsPf["rawCounts.data"])
	// exportPfBuilder.add("normHvgCount", trace.inject(exportNormCountsConv.getSpecs(blockId, species, sampleAxisSpec)), hvgNormCountsPf["normCounts.data"])
	exportPfBuilder.add("geneSymbols", geneSymbolsPf["geneSymbol.spec"], geneSymbolsPf["geneSymbol.data"])


	return {
		exports: exportPfBuilder.build(),
		cellMetricsPf: cellMetricsPf,
		rawCountsPf: rawCountsPfBuilt,
		resultsSummaryPf: resultsSummaryPf
	}
})
